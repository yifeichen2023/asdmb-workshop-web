<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>AutoRA Experiment</title>

    <!-- Styles (pin versions you use) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jspsych@8/css/jspsych.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetbean@latest/dist/style/main.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetbean@latest/dist/style/bandit.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetbean@latest/dist/style/touch-buttons.css"/>

</head>
<body>
<div id="status">Loading…</div>
<div id="root"></div>

<script type="module">
    import {initializeApp} from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import {
        getFirestore, doc, getDoc, runTransaction,
        writeBatch, setDoc, updateDoc, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    import React from "https://esm.sh/react@18";
    import ReactDOM from "https://esm.sh/react-dom@18/client";

    import {initJsPsych} from "https://esm.sh/jspsych@7";
    import htmlKeyboardResponse from "https://esm.sh/@jspsych/plugin-html-keyboard-response@2";
    import jsPsychRok from "https://esm.sh/@jspsych-contrib/plugin-rok";
    import jsPsychExtensionTouchscreenButtons from "https://esm.sh/@sweet-jspsych/extension-touchscreen-buttons";
    import * as SweetBeanRuntime from "https://esm.sh/sweetbean@latest/dist/runtime";

    globalThis.initJsPsych = initJsPsych;
    globalThis.jsPsychHtmlKeyboardResponse = htmlKeyboardResponse;
    globalThis.jsPsychRok = jsPsychRok;
    globalThis.jsPsychExtensionTouchscreenButtons = jsPsychExtensionTouchscreenButtons;
    Object.entries(SweetBeanRuntime).forEach(([k, v]) => (globalThis[k] = v));

    const $status = document.getElementById('status');
    const setStatus = (msg) => ($status.textContent = msg);

    function ErrorView({message = "An error occurred."}) {
        return React.createElement("div", null, message);
    }

    function waitPage() {
        setStatus("Saving data… Please wait.");
    }

    function endPage() {
        setStatus("Thanks! Your data was saved.");
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));

    /***********************
     * CHANGE THIS HERE: From Firebase Config
     ***********************/
    const firebaseConfig = {
        apiKey: "",
          authDomain: "",
          projectId: "",
          storageBucket: "",
          messagingSenderId: "",
          appId: "",
          measurementId: ""
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    async function getCondition(db, study, pId = null) {
        const metaRef = doc(db, study, "autora_meta");
        return await runTransaction(db, async (tx) => {
            // Read meta
            const metaSnap = await tx.get(metaRef);
            if (!metaSnap.exists()) throw new Error(`Missing document: ${study}/autora_meta`);
            const meta = metaSnap.data() || {};
            console.log(meta)

            let chosenId = null;
            for (const key of Object.keys(meta)) {
                const entry = meta[key] ?? {};
                if (entry.start_time == null) {
                    chosenId = key;
                    break;
                }
            }
            if (!chosenId) return false;

            const condRef = doc(db, study, "autora_in", "conditions", chosenId);
            const condSnap = await tx.get(condRef);
            console.log(condSnap)

            if (!condSnap.exists()) throw new Error(`Missing condition doc: ${study}/autora_in/conditions/${chosenId}`);
            const condDoc = condSnap.data() || {};
            const condition = condDoc[chosenId];
            console.log(condition)

            if (condition == null) throw new Error(`Condition doc lacks field '${chosenId}'`);

            // Now perform the write (claim the slot)
            const nowUnix = Math.floor(Date.now() / 1000);
            tx.update(metaRef, {
                [`${chosenId}.start_time`]: nowUnix,
                [`${chosenId}.claimed_at`]: serverTimestamp(),
                [`${chosenId}.finished`]: false,
                [`${chosenId}.pId`]: pId ?? null,
            });

            return [chosenId, condition];
        });
    }

    async function setObservation(db, study, id, observation, meta = true) {
        const batch = writeBatch(db);
        if (meta) {
            const metaRef = doc(db, study, "autora_meta");
            batch.update(metaRef, {
                [`${id}.finished`]: true,
                [`${id}.finished_at`]: serverTimestamp(),
            });
        }
        const outRef = doc(db, study, "autora_out", "observations", id);
        batch.set(outRef, {[id]: observation});
        await batch.commit();
    }

    async function setBackup(db, study, id, condition, observation) {
        const ms = Date.now();
        const ref = doc(db, study, "autora_out", "data_all", `${id}_${ms}`);
        await setDoc(ref, {
            condition,
            observation,
            created_at: serverTimestamp(),
            created_at_ms: ms,
            id,
        });
    }

    async function main(id, condition) {
        const code = String(condition?.experiment_code ?? "");
        if (!code.includes("runExperiment")) {
            throw new Error("experiment_code missing runExperiment()");
        }
        const observation = await eval(code + "\nrunExperiment();");
        return JSON.stringify(observation);
    }

    async function index() {
        const params = new URLSearchParams(window.location.search);

        const useProlific = params.get("useProlificId") !== "True";  // default True; override with ?useProlificId=False


        let prolificId = null;
        if (useProlific) {
            prolificId = params.get("PROLIFIC_PID");
        }

        setStatus("Fetching condition…");
        let condition;
        try {
            condition = await getCondition(db, "autora", prolificId);
        } catch (e) {
            console.error(e);
            root.render(React.createElement(React.StrictMode, null, React.createElement(ErrorView, {message: "Failed to fetch condition."})));
            return;
        }

        if (condition) {
            let observation;
            try {

                observation = await main(condition[0], condition[1]);
                setStatus("Experiment finished...")
            } catch (e) {
                console.error(e);
                root.render(React.createElement(React.StrictMode, null, React.createElement(ErrorView, {message: "Experiment error. See console."})));
                return;
            }

            try {
                waitPage();
                await setObservation(db, "autora", condition[0], observation);
                await setBackup(db, "autora", condition[0], condition[1], observation);
                endPage();
            } catch (e) {
                console.error(e);
                root.render(React.createElement(React.StrictMode, null, React.createElement(ErrorView, {message: "Failed to save data."})));
            }
        } else {
            root.render(React.createElement(React.StrictMode, null, React.createElement(ErrorView, {message: "No condition found."})));
        }
    }

    // Go!
    index().catch((e) => {
        console.error(e);
        root.render(React.createElement(React.StrictMode, null, React.createElement(ErrorView, {message: "Unexpected error. Check console."})));
    });
</script>
</body>
</html>
